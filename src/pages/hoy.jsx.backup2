import React, { useState, useEffect, useRef } from "react";
import { updateBackpackFromSession } from '@/shared/services/backpackService';
import { localDataClient } from "@/api/localDataClient";
import { createRemoteDataAPI } from "@/api/remoteDataAPI";
import { useAsignaciones } from "@/hooks/entities/useAsignaciones";
import { useCurrentProfile } from "@/hooks/useCurrentProfile";

// Create remote API instance for fetching bloques with variations
const remoteDataAPI = createRemoteDataAPI();
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ds";
import { Button } from "@/components/ds/Button"; // Updated import path
import { Badge } from "@/components/ds";
import { Alert, AlertDescription, AlertTitle } from "@/components/ds";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  ChevronLeft,
  ChevronRight,
  Pause,
  Play,
  RotateCcw,
  SkipForward,
  Maximize2,
  BookOpen,
  CheckCircle,
  Clock,
  Music,
  MoreVertical,
  Flag,
  ChevronsRight,
  ChevronUp,
  ChevronDown,
  Target,
  X,
  Piano,
  PlayCircle,
  User,
  Calendar,
  Layers,
  AlertTriangle,
  List,
  HelpCircle,
  Minimize2,
  XCircle,
  Shuffle,
  Menu,
  ShieldAlert,
  Save,
  FileText,
  Video,
  ExternalLink,
  ImageIcon,
  Backpack
} from "lucide-react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { createPageUrl } from "@/utils";
import { cn } from "@/lib/utils";
import { toStudia } from "@/lib/routes";
import {
  calcularLunesSemanaISO,
  calcularOffsetSemanas,
  calcularTiempoSesion,
  aplanarSesion,
  getNombreVisible,
  formatLocalDate,
  parseLocalDate,
  isoWeekNumberLocal
} from "../components/utils/helpers";
import { useEffectiveUser } from "@/providers/EffectiveUserProvider";
import PeriodHeader from "../components/common/PeriodHeader";
import { getSecuencia, ensureRondaIds, mapBloquesByCode } from "../components/study/sessionSequence";
import TimelineProgreso from "../features/estudio/components/TimelineProgreso";
import ModalCancelar from "../features/estudio/components/ModalCancelar";
import ResumenFinal from "../features/estudio/components/ResumenFinal";
import Metronomo from "../components/study/Metronomo";
import PianoPanel from "../components/study/PianoPanel"; // Refactored component
import SessionContentView from "../components/study/SessionContentView";
// detectMediaType eliminado, usamos resolveMedia de media.jsx

import ReportErrorButtonInTimer from "../components/common/ReportErrorButtonInTimer";
import { toast } from "sonner";
import { useSidebar } from "@/components/ui/SidebarState";
import PageHeader from "@/components/ds/PageHeader";
import { componentStyles } from "@/design/componentStyles";
import MediaEmbed from "../components/common/MediaEmbed";
import CustomAudioPlayer from "../components/common/CustomAudioPlayer";
import { MediaIcon, getMediaLabel } from "../components/common/MediaEmbed";
import { resolveMedia, MediaKind } from "../components/utils/media";
import { shouldIgnoreHotkey } from "@/utils/hotkeys";
import { useHotkeysModal } from "@/hooks/useHotkeysModal.jsx";
import { getValidVariations, pickRandomVariation } from "@/hooks/useExerciseVariations";

import RequireRole from "@/components/auth/RequireRole";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

// --- Helpers de fechas locales (para formateo de semana) ---
const startOfMonday = (date) => {
  const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const dow = d.getDay();
  const diff = dow === 0 ? -6 : 1 - dow;
  d.setDate(d.getDate() + diff);
  return d;
};

const InfoSection = ({ title, icon, children, defaultOpen = true }) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);
  return (
    <div className="border-b border-[var(--color-border-default)] pb-3 md:pb-4 last:border-b-0">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 w-full text-left mb-1.5 md:mb-2 group"
      >
        {isOpen ? <ChevronDown className="w-4 h-4 text-[var(--color-text-secondary)]" /> : <ChevronRight className="w-4 h-4 text-[var(--color-text-secondary)]" />}
        <span className={`${componentStyles.typography.sectionTitle} text-[var(--color-text-primary)] group-hover:text-[var(--color-primary)] transition-colors flex items-center gap-2`}>
          {icon && <span>{icon}</span>}
          {title}
        </span>
      </button>
      {isOpen && (
        <div className="pl-6 animate-in fade-in slide-in-from-top-1 duration-200">
          {children}
        </div>
      )}
    </div>
  );
};

export default function HoyPage() {
  return (
    <RequireRole anyOf={['ESTU']}>
      <HoyPageContent />
    </RequireRole>
  );
}

function HoyPageContent() {
  const navigate = useNavigate();
  const { closeSidebar, abierto, toggleSidebar } = useSidebar();
  const { showHotkeysModal, setShowHotkeysModal } = useHotkeysModal();

  const [semanaActualISO, setSemanaActualISO] = useState(() => {
    return calcularLunesSemanaISO(new Date());
  });

  const cambiarSemana = (direccion) => {
    const base = parseLocalDate(semanaActualISO);
    base.setDate(base.getDate() + (direccion * 7));
    const lunes = startOfMonday(base);
    const nextISO = formatLocalDate(lunes);
    if (nextISO !== semanaActualISO) setSemanaActualISO(nextISO);
  };

  const irSemanaActual = () => {
    const lunes = startOfMonday(new Date());
    setSemanaActualISO(formatLocalDate(lunes));
  };


  const [asignacionSeleccionadaId, setAsignacionSeleccionadaId] = useState(null); // Para múltiples asignaciones
  const [sesionSeleccionada, setSesionSeleccionada] = useState(0);
  const [sesionesConResumenExpandido, setSesionesConResumenExpandido] = useState(new Set());
  const [sesionActiva, setSesionActiva] = useState(null);

  const [indiceActual, setIndiceActual] = useState(0);
  const [tiempoActual, setTiempoActual] = useState(0);
  const [cronometroActivo, setCronometroActiva] = useState(false);
  // Layout and UI state
  const [timerCollapsed, setTimerCollapsed] = useState(false); // Collapsed by default? No, usually open.
  const [footerHeight, setFooterHeight] = useState(80); // Default height
  const footerRef = useRef(null);

  // Desktop detection for sidebar-aware positioning
  const [isDesktop, setIsDesktop] = useState(() => typeof window !== 'undefined' && window.innerWidth >= 1024);

  useEffect(() => {
    const handleResize = () => {
      setIsDesktop(window.innerWidth >= 1024);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Measure footer height for PianoPanel positioning
  // Helper to get REAL bottom offset
  const measureFooterOffset = () => {
    if (!footerRef.current) return 0;
    const viewportH = window.visualViewport?.height ?? window.innerHeight;
    const rect = footerRef.current.getBoundingClientRect();
    const offset = Math.max(0, Math.round(viewportH - rect.top));
    return offset;
  };

  useEffect(() => {
    if (!footerRef.current) return;

    const updateFooterHeight = () => {
      const h = measureFooterOffset();
      setFooterHeight(h);
    };

    // Initial measure with robust loop for load stability (Chrome Hotfix)
    const measureAndLoop = () => {
      updateFooterHeight();
      let rafId;
      const startTime = performance.now();
      const loop = (time) => {
        updateFooterHeight();
        // Poll for 1000ms to ensure initial layout/transitions (e.g. fonts, dynamic content) are caught
        if (time - startTime < 1000) {
          rafId = requestAnimationFrame(loop);
        }
      };
      rafId = requestAnimationFrame(loop);
      return () => cancelAnimationFrame(rafId);
    };

    const cancelLoop = measureAndLoop();

    // ResizeObserver
    const resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(updateFooterHeight);
    });

    resizeObserver.observe(footerRef.current);

    // Window resize fallback
    window.addEventListener('resize', updateFooterHeight);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', updateFooterHeight);
    }

    return () => {
      cancelLoop();
      resizeObserver.disconnect();
      window.removeEventListener('resize', updateFooterHeight);
      if (window.visualViewport) {
        window.visualViewport.removeEventListener('resize', updateFooterHeight);
      }
    };
  }, []);

  // Force re-measure when collapse state changes (Chrome Hotfix)
  useEffect(() => {
    if (!footerRef.current) return;
    const update = () => setFooterHeight(measureFooterOffset());
    update();

    let rafId;
    const startTime = performance.now();
    const loop = (time) => {
      update();
      if (time - startTime < 400) {
        rafId = requestAnimationFrame(loop);
      }
    };
    rafId = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(rafId);
  }, [timerCollapsed]);

  // Handler for Piano Toggle
  const handleTogglePiano = () => {
    if (!mostrarPiano) {
      // Opening: Force measure FIRST
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const offset = measureFooterOffset();
          setFooterHeight(offset);
          setMostrarPiano(true);
        });
      });
      // Backup check
      setTimeout(() => {
        setFooterHeight(measureFooterOffset());
      }, 80);
    } else {
      setMostrarPiano(false);
    }
  };
  const [completados, setCompletados] = useState(new Set());
  const [omitidos, setOmitidos] = useState(new Set());
  const [pantallaCompleta, setPantallaCompleta] = useState(false);
  const [mostrarItinerario, setMostrarItinerario] = useState(false);
  const [mostrarModalCancelar, setMostrarModalCancelar] = useState(false);
  const [rondasExpandidasItinerario, setRondasExpandidasItinerario] = useState(new Set());
  const [cronometroPausadoPorModal, setCronometroPausadoPorModal] = useState(false);
  const [sesionFinalizada, setSesionFinalizada] = useState(false);
  const [datosFinal, setDatosFinal] = useState(null);
  const [mediaFullscreen, setMediaFullscreen] = useState(null);
  const [mediaModal, setMediaModal] = useState(null); // Para el popup de materiales
  const [reportModalAbierto, setReportModalAbierto] = useState(false);
  const [pianoCerradoPorUsuario, setPianoCerradoPorUsuario] = useState(true); // Control del fab del piano
  const [mostrarPiano, setMostrarPiano] = useState(false); // Modal del piano
  const [ppmAlcanzado, setPpmAlcanzado] = useState(null);

  // Estado para la posición del timer arrastrable
  const [timerPosition, setTimerPosition] = useState(() => {
    const saved = localStorage.getItem('timer-position');
    if (saved) {
      try {
        const { top, left } = JSON.parse(saved);
        return { top, left };
      } catch (e) {
        // Si hay error, usar valores por defecto
      }
    }
    // Valores por defecto: esquina superior derecha
    return { top: 16, left: null, right: 16 };
  });
  const [isDraggingTimer, setIsDraggingTimer] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const timerRef = useRef(null);

  const [registroSesionId, setRegistroSesionId] = useState(null);
  const [timestampInicio, setTimestampInicio] = useState(null);
  const [timestampUltimoPausa, setTimestampUltimoPausa] = useState(null);
  const [tiempoAcumuladoAntesPausa, setTiempoAcumuladoAntesPausa] = useState(0);
  const heartbeatIntervalRef = useRef(null);
  const colaOfflineRef = useRef([]);
  const bloquesPendientesRef = useRef([]); // Almacenar bloques en memoria hasta finalizar

  const sidebarCerradoRef = useRef(false);

  // Usar el nuevo provider de impersonación para obtener el usuario efectivo
  const { effectiveUserId, effectiveEmail, isImpersonating } = useEffectiveUser();

  // Usar hook optimizado para perfil actual (usa caché de useUsers)
  const { profile: alumnoActual } = useCurrentProfile();

  // Usar el ID del usuario efectivo (impersonado o real)
  const userIdActual = alumnoActual?.id || effectiveUserId;


  // Usar hook centralizado para asignaciones
  const { data: asignacionesRaw = [] } = useAsignaciones();

  // Cargar bloques actuales desde Supabase (remoteDataAPI tiene content → variations mapping)
  const { data: bloquesActuales = [] } = useQuery({
    queryKey: ['bloques-with-variations'],
    queryFn: async () => {
      try {
        // Fetch from Supabase to get content/variations field
        const bloques = await remoteDataAPI.bloques.list();
        if (bloques) {
          console.log('[DEBUG] bloquesActuales sample (from Supabase):', bloques.slice(0, 3).map(b => ({
            code: b.code,
            nombre: b.nombre,
            variations: b.variations,
            hasVariations: !!(b.variations && b.variations.length > 0)
          })));
        }
        return bloques || [];
      } catch (error) {
        console.error('Error fetching bloques from Supabase, falling back to localStorage:', error);
        // Fallback to localStorage if Supabase fails
        const localRes = await localDataClient.entities.Bloque.list();
        return localRes || [];
      }
    },
    staleTime: 30 * 1000, // 30s - needs recent data for study session
  });


  // Filtrar y validar asignaciones
  const asignaciones = asignacionesRaw.filter(a => {
    // Validar que tiene alumnoId válido
    if (!a.alumnoId) {
      return false;
    }
    // Validar que tiene alumnoId válido
    if (!a.alumnoId) {
      return false;
    }

    // Validar existencia de perfil (usando datos embebidos del RPC si están disponibles)
    // Si no tenemos alumnos cargados (porque quitamos useUsers), confiamos en el RPC o en que es el usuario actual.
    // Simplificación: Si es el usuario actual, siempre permitir.
    // Si la asignación tiene alumnoId, asumimos que es válida para ese alumno.
    // El RPC trae 'alumnoNombre'. Si es null, el perfil quizás no existe, pero la asignación sí.
    // Mantenemos lógica defensiva mínima:

    // Si no coincide con el usuario actual, se filtrará más adelante en asignacionesActivas.
    // Esta validación previa era para asegurar consistencia de datos.
    if (!userIdActual) return false;

    // Validar que tiene plan y semanas
    if (!a.plan || !Array.isArray(a.plan.semanas) || a.plan.semanas.length === 0) {
      return false;
    }

    // Validar que tiene semanaInicioISO válida
    if (!a.semanaInicioISO || typeof a.semanaInicioISO !== 'string') {
      return false;
    }

    return true;
  });


  // Filtrar asignaciones activas (que tienen semana válida para la semana actual)
  const asignacionesActivas = asignaciones.filter(a => {
    if (a.alumnoId !== userIdActual) return false;
    if (a.estado !== 'publicada' && a.estado !== 'en_curso') return false;
    try {
      const offset = calcularOffsetSemanas(a.semanaInicioISO, semanaActualISO);
      const tieneSemanaValida = offset >= 0 && offset < (a.plan?.semanas?.length || 0);
      return tieneSemanaValida;
    } catch (error) {
      return false;
    }
  });

  // Determinar asignación activa: si hay selección, usarla; sino, la primera
  const asignacionActiva = asignacionSeleccionadaId
    ? asignacionesActivas.find(a => a.id === asignacionSeleccionadaId)
    : asignacionesActivas[0] || null;

  // Si no hay selección y hay asignaciones, seleccionar la primera automáticamente
  useEffect(() => {
    if (!asignacionSeleccionadaId && asignacionesActivas.length > 0) {
      setAsignacionSeleccionadaId(asignacionesActivas[0].id);
    }
  }, [asignacionesActivas.length, asignacionSeleccionadaId]);

  // Calcular semanaDelPlan de forma más robusta
  let semanaDelPlan = null;
  let semanaIdx = 0;

  if (asignacionActiva) {
    try {
      semanaIdx = calcularOffsetSemanas(asignacionActiva.semanaInicioISO, semanaActualISO);
      semanaDelPlan = asignacionActiva.plan?.semanas?.[semanaIdx] || null;
    } catch (error) {
      semanaDelPlan = null;
    }
  }

  useEffect(() => {
    if (sesionActiva && !sesionFinalizada && !sidebarCerradoRef.current) {
      closeSidebar();
      sidebarCerradoRef.current = true;
    }
    if (!sesionActiva) {
      sidebarCerradoRef.current = false;
    }
  }, [sesionActiva, sesionFinalizada, closeSidebar]);

  // Notificar cuando el timer está visible o no
  useEffect(() => {
    window.dispatchEvent(new CustomEvent('timer-state-change', {
      detail: { visible: !!sesionActiva }
    }));

    return () => {
      // Notificar cuando el timer se oculta
      window.dispatchEvent(new CustomEvent('timer-state-change', {
        detail: { visible: false }
      }));
    };
  }, [sesionActiva]);

  // useEffect para manejar el arrastre del timer
  useEffect(() => {
    if (!isDraggingTimer) return;

    const handleMouseMove = (e) => {
      const newLeft = e.clientX - dragOffset.x;
      const newTop = e.clientY - dragOffset.y;

      // Limitar a los bordes de la ventana
      const maxLeft = window.innerWidth - (timerRef.current?.offsetWidth || 200);
      const maxTop = window.innerHeight - (timerRef.current?.offsetHeight || 100);
      const minLeft = 0;
      const minTop = 0;

      const clampedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
      const clampedTop = Math.max(minTop, Math.min(maxTop, newTop));

      const newPosition = { top: clampedTop, left: clampedLeft, right: null };
      setTimerPosition(newPosition);

      // Guardar en localStorage
      localStorage.setItem('timer-position', JSON.stringify({ top: clampedTop, left: clampedLeft }));
    };

    const handleTouchMove = (e) => {
      const touch = e.touches[0];
      const newLeft = touch.clientX - dragOffset.x;
      const newTop = touch.clientY - dragOffset.y;

      // Limitar a los bordes de la ventana
      const maxLeft = window.innerWidth - (timerRef.current?.offsetWidth || 200);
      const maxTop = window.innerHeight - (timerRef.current?.offsetHeight || 100);
      const minLeft = 0;
      const minTop = 0;

      const clampedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
      const clampedTop = Math.max(minTop, Math.min(maxTop, newTop));

      const newPosition = { top: clampedTop, left: clampedLeft, right: null };
      setTimerPosition(newPosition);

      // Guardar en localStorage
      localStorage.setItem('timer-position', JSON.stringify({ top: clampedTop, left: clampedLeft }));
    };

    const handleMouseUp = () => {
      setIsDraggingTimer(false);
    };

    const handleTouchEnd = () => {
      setIsDraggingTimer(false);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
    };
  }, [isDraggingTimer, dragOffset]);

  // Handlers para arrastrar el timer (usando useCallback para mantener referencias estables)
  const handleTimerMouseDown = React.useCallback((e) => {
    if (!timerRef.current) return;
    const rect = timerRef.current.getBoundingClientRect();
    setDragOffset({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    });
    setIsDraggingTimer(true);
    e.preventDefault();
  }, []);

  const handleTimerTouchStart = React.useCallback((e) => {
    if (!timerRef.current) return;
    const touch = e.touches[0];
    const rect = timerRef.current.getBoundingClientRect();
    setDragOffset({
      x: touch.clientX - rect.left,
      y: touch.clientY - rect.top,
    });
    setIsDraggingTimer(true);
    e.preventDefault();
  }, []);

  useEffect(() => {
    if (!cronometroActivo || !sesionActiva || sesionFinalizada) {
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }
      return;
    }

    const listaEjecucion = aplanarSesion(sesionActiva);
    const ejercicioActual = listaEjecucion[indiceActual];

    if (ejercicioActual?.tipo === 'AD') {
      setCronometroActiva(false);
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }
      return;
    }

    const interval = setInterval(() => {
      const ahora = Date.now();
      const tiempoDesdeInicio = timestampInicio ? Math.floor((ahora - timestampInicio) / 1000) : 0;
      const tiempoTotal = tiempoAcumuladoAntesPausa + tiempoDesdeInicio;

      if (tiempoTotal >= 18000) {
        setTiempoActual(18000);
        setCronometroActiva(false);
        toast.error("⏳ Tiempo máximo alcanzado (5h). Sesión guardada.");
        setSesionFinalizada(true);
        return;
      }

      setTiempoActual(tiempoTotal);
    }, 1000);

    return () => clearInterval(interval);
  }, [cronometroActivo, sesionActiva, indiceActual, sesionFinalizada, timestampInicio, tiempoAcumuladoAntesPausa]);

  // NOTA: guardarRegistroSesion eliminado, se reemplaza por finalizarSesion

  const guardarRegistroBloque = async (indice, estado, duracionReal = 0) => {
    if (!sesionActiva) return;

    const listaEjecucion = aplanarSesion(sesionActiva);
    const bloque = listaEjecucion[indice];
    if (!bloque) return;

    const dataBloque = {
      // registroSesionId: se asignará al finalizar
      asignacionId: asignacionActiva.id,
      alumnoId: userIdActual,
      semanaIdx: semanaIdx,
      sesionIdx: semanaDelPlan?.sesiones?.indexOf(sesionActiva) || 0,
      ordenEjecucion: indice,
      tipo: bloque.tipo,
      code: bloque.code,
      nombre: bloque.nombre,
      duracionObjetivoSeg: bloque.duracionSeg || 0,
      duracionRealSeg: bloque.tipo === 'AD' ? 0 : duracionReal,
      estado: estado,
      inicioISO: new Date().toISOString(),
      finISO: new Date().toISOString(),
      iniciosPausa: 0,
      ppmAlcanzado: ppmAlcanzado,
      // Nuevos campos para Mochila
      backpack_key: bloque.backpack_key || null,
      variation_key: bloque.variation_key || null,
      ppm_objetivo: bloque.targetPPMs?.[0] || null, // Asumimos el primer target como objetivo principal si existe
    };

    // Guardar en memoria
    bloquesPendientesRef.current.push(dataBloque);
    console.log('Bloque guardado en memoria:', dataBloque);
  };

  // NOTA: Eliminados los useEffect que actualizaban el registro periódicamente
  // El registro solo se actualiza una vez al final cuando el usuario presiona "Finalizar" en ResumenFinal

  useEffect(() => {
    if (!sesionActiva || sesionFinalizada) return;
    const listaEjecucion = aplanarSesion(sesionActiva);
    const ejercicioActual = listaEjecucion[indiceActual];

    if (ejercicioActual?.tipo !== 'AD' && document.hasFocus()) {
      if (!cronometroActivo) {
        const ahora = Date.now();
        setTimestampInicio(ahora);
        setTiempoAcumuladoAntesPausa(0);
        setTimestampUltimoPausa(null);
        setCronometroActiva(true);
      }
    } else {
      setCronometroActiva(false);
      setTimestampInicio(null);
      setTiempoAcumuladoAntesPausa(0);
      setTimestampUltimoPausa(null);
    }
    setPpmAlcanzado(null); // Resetear PPM al cambiar de ejercicio
  }, [indiceActual, sesionActiva, sesionFinalizada]);


  // Expandir todas las rondas por defecto cuando se abre el panel de itinerario
  useEffect(() => {
    if (mostrarItinerario && sesionActiva) {
      const S = ensureRondaIds(sesionActiva);
      const secuencia = getSecuencia(S);
      const todasLasRondas = new Set(
        secuencia
          .filter(item => item.kind === 'RONDA' && item.id)
          .map(item => item.id)
      );
      setRondasExpandidasItinerario(todasLasRondas);
    }
  }, [mostrarItinerario, sesionActiva]);

  // Escuchar eventos del modal de reportes
  useEffect(() => {
    const handleReportModalOpened = () => setReportModalAbierto(true);
    const handleReportModalClosed = () => setReportModalAbierto(false);

    window.addEventListener('report-modal-opened', handleReportModalOpened);
    window.addEventListener('report-modal-closed', handleReportModalClosed);

    return () => {
      window.removeEventListener('report-modal-opened', handleReportModalOpened);
      window.removeEventListener('report-modal-closed', handleReportModalClosed);
    };
  }, []);

  // Pausar/reanudar cronómetro cuando se abren/cierran modales
  useEffect(() => {
    const hayModalAbierto = mostrarModalCancelar || mostrarItinerario || reportModalAbierto || showHotkeysModal;

    if (hayModalAbierto && cronometroActivo && !cronometroPausadoPorModal) {
      // Pausar el cronómetro
      const ahora = Date.now();
      const tiempoDesdeInicio = timestampInicio ? Math.floor((ahora - timestampInicio) / 1000) : 0;
      setTiempoAcumuladoAntesPausa(prev => prev + tiempoDesdeInicio);
      setTimestampUltimoPausa(ahora);
      setTimestampInicio(null);
      setCronometroActiva(false);
      setCronometroPausadoPorModal(true);
    } else if (!hayModalAbierto && cronometroPausadoPorModal && sesionActiva && !sesionFinalizada) {
      // Reanudar el cronómetro
      const ahora = Date.now();
      setTimestampInicio(ahora);
      setTimestampUltimoPausa(null);
      setCronometroActiva(true);
      setCronometroPausadoPorModal(false);
    }
  }, [mostrarModalCancelar, mostrarItinerario, reportModalAbierto, showHotkeysModal, cronometroActivo, cronometroPausadoPorModal, sesionActiva, sesionFinalizada, timestampInicio]);

  const empezarSesion = (sesion, sesionIdxProp) => {
    // Navigate to /studia with context
    const url = toStudia({
      asignacionId: asignacionActiva?.id,
      semanaIdx: semanaIdx,
      sesionIdx: sesionIdxProp,
    });
    navigate(url);
  };

  // Listener para el hotkey global Ctrl+Alt+S "Studia ahora"
  // DEBE estar después de la declaración de empezarSesion
  useEffect(() => {
    const handleStartStudySession = async () => {
      // Verificar que no hay sesión activa
      if (sesionActiva) return;

      // Verificar que hay asignación activa y semana del plan
      if (!asignacionActiva || !semanaDelPlan) {
        toast.info('No tienes asignaciones activas. Habla con tu profesor.');
        return;
      }

      // Verificar que hay sesiones disponibles
      if (!semanaDelPlan.sesiones || semanaDelPlan.sesiones.length === 0) {
        toast.info('No hay sesiones disponibles para esta semana.');
        return;
      }

      // Seleccionar automáticamente la primera sesión si no hay ninguna seleccionada
      // o si la seleccionada no es válida
      const primeraSesionIdx = 0;
      const primeraSesion = semanaDelPlan.sesiones[primeraSesionIdx];

      if (!primeraSesion) {
        toast.info('No hay sesiones disponibles para esta semana.');
        return;
      }

      // Asegurar que la sesión esté seleccionada
      setSesionSeleccionada(primeraSesionIdx);

      // Iniciar la primera sesión automáticamente
      await empezarSesion(primeraSesion, primeraSesionIdx);
    };

    window.addEventListener('start-study-session', handleStartStudySession);

    return () => {
      window.removeEventListener('start-study-session', handleStartStudySession);
    };
  }, [asignacionActiva, semanaDelPlan, sesionActiva, empezarSesion, setSesionSeleccionada]);

  const cerrarSesion = () => {
    setCronometroActiva(false);
    setSesionActiva(null);
    setIndiceActual(0);
    setTiempoActual(0);
    setCompletados(new Set());
    setOmitidos(new Set());
    setPantallaCompleta(false);
    setMostrarItinerario(false);
    setSesionFinalizada(false);
    setDatosFinal(null);
    setRegistroSesionId(null);
    setTimestampInicio(null);
    setTimestampUltimoPausa(null);
    setTiempoAcumuladoAntesPausa(0);
  };

  const reiniciarSesion = () => {
    setIndiceActual(0);
    setTiempoActual(0);
    setCronometroActiva(false);
    setCompletados(new Set());
    setOmitidos(new Set());
    setSesionFinalizada(false);
    setDatosFinal(null);

    const ahora = Date.now();
    setTimestampInicio(ahora);
    setTimestampUltimoPausa(null);
    setTiempoAcumuladoAntesPausa(0);
  };

  const togglePlayPausa = () => {
    const ahora = Date.now();

    if (cronometroActivo) {
      const tiempoDesdeInicio = timestampInicio ? Math.floor((ahora - timestampInicio) / 1000) : 0;
      setTiempoAcumuladoAntesPausa(prev => prev + tiempoDesdeInicio);
      setTimestampUltimoPausa(ahora);
      setTimestampInicio(null);
      setCronometroActiva(false);
    } else {
      setTimestampInicio(ahora);
      setTimestampUltimoPausa(null);
      setCronometroActiva(true);
    }
  };

  const handleAnterior = () => {
    if (indiceActual > 0) {
      setCronometroActiva(false);
      setIndiceActual(prev => prev - 1);
      setTiempoActual(0);
      const ahora = Date.now();
      setTimestampInicio(ahora);
      setTiempoAcumuladoAntesPausa(0);
      setTimestampUltimoPausa(null);
    }
  };

  const omitirYAvanzar = async () => {
    const listaEjecucion = aplanarSesion(sesionActiva);

    await guardarRegistroBloque(indiceActual, 'omitido', 0);

    const newCompletados = new Set(completados);
    const newOmitidos = new Set(omitidos);
    newOmitidos.add(indiceActual);
    newCompletados.delete(indiceActual);
    setCompletados(newCompletados);
    setOmitidos(newOmitidos);

    // NO actualizar registro de sesión aquí - solo se actualiza al final en ResumenFinal

    toast.info("⏭️ Ejercicio omitido");

    if (indiceActual === listaEjecucion.length - 1) {
      setSesionFinalizada(true);
    } else {
      setCronometroActiva(false);
      setIndiceActual(prev => prev + 1);
      setTiempoActual(0);
      const ahora = Date.now();
      setTimestampInicio(ahora);
      setTiempoAcumuladoAntesPausa(0);
      setTimestampUltimoPausa(null);
    }
  };

  const completarYAvanzar = async () => {
    const listaEjecucion = aplanarSesion(sesionActiva);

    await guardarRegistroBloque(indiceActual, 'completado', tiempoActual);

    const newCompletados = new Set(completados);
    const newOmitidos = new Set(omitidos);
    newCompletados.add(indiceActual);
    newOmitidos.delete(indiceActual);
    setCompletados(newCompletados);
    setOmitidos(newOmitidos);

    // NO actualizar registro de sesión aquí - solo se actualiza al final en ResumenFinal

    if (indiceActual === listaEjecucion.length - 1) {
      setSesionFinalizada(true);
    } else {
      setCronometroActiva(false);
      setIndiceActual(prev => prev + 1);
      setTiempoActual(0);
      const ahora = Date.now();
      setTimestampInicio(ahora);
      setTiempoAcumuladoAntesPausa(0);
      setTimestampUltimoPausa(null);
    }
  };

  // Manejo de atajos de teclado - debe estar después de las definiciones de funciones
  useEffect(() => {
    if (!sesionActiva || sesionFinalizada) return;

    const handleKeyDown = (e) => {
      // No procesar si hay un modal abierto (excepto para cerrar modales)
      const hayModalAbierto = mostrarModalCancelar || mostrarItinerario || reportModalAbierto || showHotkeysModal;

      // Permitir Escape siempre para cerrar modales
      if (e.key === 'Escape') {
        e.preventDefault();
        if (mediaFullscreen) {
          setMediaFullscreen(null);
        } else if (mediaModal) {
          setMediaModal(null);
        } else if (mostrarItinerario) {
          setMostrarItinerario(false);
        } else if (mostrarModalCancelar) {
          setMostrarModalCancelar(false);
        } else if (sesionActiva && !sesionFinalizada) {
          // Si no hay modales abiertos y hay sesión activa, abrir modal de cancelar
          setMostrarModalCancelar(true);
        }
        return;
      }

      // Si el modal de reporte está abierto, no permitir ningún hotkey (excepto Escape)
      if (reportModalAbierto) {
        return;
      }

      // Permitir 'I' para toggle del índice siempre (incluso cuando está abierto, excepto con modal de reporte)
      if (e.key === 'i' || e.key === 'I') {
        e.preventDefault();
        setMostrarItinerario(prev => !prev);
        return;
      }

      // Permitir '?' para toggle de ayuda siempre (incluso cuando está abierto, excepto con modal de reporte)
      if (e.key === '?') {
        e.preventDefault();
        setShowHotkeysModal(prev => !prev);
        return;
      }

      // Si hay un modal abierto, no procesar otros atajos
      if (hayModalAbierto) return;

      // Usar helper centralizado para detectar campos editables
      if (shouldIgnoreHotkey(e)) return;

      // Espacio: play/pause del reproductor de audio
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        const listaEjecucion = aplanarSesion(sesionActiva);
        const ejercicioActual = listaEjecucion[indiceActual];
        if (ejercicioActual?.tipo !== 'AD') {
          togglePlayPausa();
        }
      }

      // Flecha izquierda: ejercicio anterior
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (indiceActual > 0) {
          handleAnterior();
        }
      }

      // Flecha derecha: ejercicio siguiente
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        const listaEjecucion = aplanarSesion(sesionActiva);
        if (indiceActual < listaEjecucion.length - 1) {
          omitirYAvanzar(); // O usar completarYAvanzar según lógica
        }
      }

      // Tecla O: completar ejercicio actual (OK)
      if (e.key === 'o' || e.key === 'O') {
        e.preventDefault();
        completarYAvanzar();
      }

      // Enter: también completar ejercicio (mantener compatibilidad)
      if (e.key === 'Enter') {
        e.preventDefault();
        completarYAvanzar();
      }

      // Tecla N: omitir ejercicio (mantener compatibilidad)
      if (e.key === 'n' || e.key === 'N') {
        e.preventDefault();
        omitirYAvanzar();
      }

      // Tecla P: ejercicio anterior (mantener compatibilidad)
      if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        handleAnterior();
      }
    };

    window.addEventListener('keydown', handleKeyDown, true);

    return () => {
      window.removeEventListener('keydown', handleKeyDown, true);
    };
  }, [sesionActiva, sesionFinalizada, indiceActual, mediaFullscreen, mostrarItinerario, mostrarModalCancelar, togglePlayPausa, completarYAvanzar, omitirYAvanzar, handleAnterior, reportModalAbierto, setShowHotkeysModal]);

  const handleCancelar = () => {
    setMostrarModalCancelar(true);
  };

  const guardarYSalir = async () => {
    // NO actualizar registro aquí - solo se actualiza al final en ResumenFinal cuando el usuario presiona "Finalizar"
    setMostrarModalCancelar(false);
    // Finalizar la sesión para mostrar el feedback en lugar de cerrar directamente
    setSesionFinalizada(true);
  };

  const salirSinGuardar = () => {
    setMostrarModalCancelar(false);
    cerrarSesion();
    // In try mode, navigate back to previous page
    if (isTryMode) {
      navigate(-1);
    }
  };

  const navegarA = (idx) => {
    setCronometroActiva(false);
    setIndiceActual(idx);
    setTiempoActual(0);
    const ahora = Date.now();
    setTimestampInicio(ahora);
    setTiempoAcumuladoAntesPausa(0);
    setTimestampUltimoPausa(null);
    setMostrarItinerario(false);
  };


  const tipoColors = {
    CA: componentStyles.status.badgeDefault, // brand -> default
    CB: componentStyles.status.badgeInfo,
    TC: componentStyles.status.badgeDefault, // purple -> default
    TM: componentStyles.status.badgeSuccess,
    FM: componentStyles.status.badgeDefault, // pink -> default
    VC: componentStyles.status.badgeInfo, // cyan -> info
    AD: componentStyles.status.badgeDefault,
  };

  const focoLabels = {
    GEN: 'General',
    SON: 'Sonido',
    FLX: 'Flexibilidad',
    MOT: 'Motricidad',
    ART: 'Articulación',
    COG: 'Cognitivo',
  };

  const focoColors = {
    GEN: componentStyles.status.badgeDefault,
    LIG: componentStyles.status.badgeInfo,
    RIT: componentStyles.status.badgeDefault, // purple -> default
    ART: componentStyles.status.badgeSuccess,
    'S&A': componentStyles.status.badgeDefault, // brand -> default
  };

  const finalizarSesion = async (calidad, notas, mediaLinks) => {
    // TRY MODE: Skip all persistence and navigate back
    if (isTryMode) {
      console.log('[TryMode] Skipping persistence - navigating back');
      cerrarSesion();
      navigate(-1);
      return;
    }

    if (!asignacionActiva || !sesionActiva) return;

    const listaEjecucion = aplanarSesion(sesionActiva);
    const tiempoPrevisto = listaEjecucion
      .filter(e => e.tipo !== 'AD')
      .reduce((sum, e) => sum + (e.duracionSeg || 0), 0);

    // Calcular duración total real sumando duraciones de bloques completados
    // Esto asegura consistencia con los bloques guardados
    const duracionRealTotal = bloquesPendientesRef.current.reduce((acc, b) => acc + (b.duracionRealSeg || 0), 0);

    const dataRegistro = {
      asignacionId: asignacionActiva.id,
      alumnoId: userIdActual,
      profesorAsignadoId: alumnoActual?.profesorAsignadoId || null,
      semanaIdx: semanaIdx,
      sesionIdx: semanaDelPlan?.sesiones?.indexOf(sesionActiva) || 0,
      inicioISO: timestampInicio ? new Date(timestampInicio).toISOString() : new Date().toISOString(),
      finISO: new Date().toISOString(),
      duracionRealSeg: duracionRealTotal, // Usar la suma de bloques
      duracionObjetivoSeg: tiempoPrevisto,
      bloquesTotales: listaEjecucion.length,
      bloquesCompletados: completados.size,
      bloquesOmitidos: omitidos.size,
      finalizada: true,
      finAnticipado: false,
      motivoFin: null,
      calificacion: calidad,
      notas: notas,
      mediaLinks: mediaLinks || [],
      dispositivo: navigator.userAgent,
      versionSchema: "1.0",
      piezaNombre: asignacionActiva.piezaSnapshot?.nombre || '',
      planNombre: asignacionActiva.plan?.nombre || '',
      semanaNombre: semanaDelPlan?.nombre || '',
      sesionNombre: sesionActiva.nombre || '',
      foco: sesionActiva.foco || 'GEN',
    };

    try {
      // 1. Crear la sesión
      const nuevoRegistro = await localDataClient.entities.RegistroSesion.create(dataRegistro);
      const nuevoId = nuevoRegistro.id;
      setRegistroSesionId(nuevoId);

      // 2. Guardar todos los bloques pendientes vinculados a esta sesión en una sola llamada (bulk)
      const bloquesToCreate = bloquesPendientesRef.current.map(bloque => ({
        ...bloque,
        registroSesionId: nuevoId
      }));

      await localDataClient.entities.RegistroBloque.bulkCreate(bloquesToCreate);

      // --- BACKPACK INTEGRATION ---
      try {
        await updateBackpackFromSession({
          studentId: userIdActual,
          registrosBloque: bloquesPendientesRef.current // Pasamos los bloques con sus nuevos campos
        });
        console.log("Backpack actualizada correctamente");
      } catch (bpError) {
        console.error("Error actualizando backpack:", bpError);
        // No bloqueamos el flujo principal si falla esto, pero lo logueamos
      }

      toast.success("✅ Sesión guardada correctamente");

      // Limpiar cola
      bloquesPendientesRef.current = [];

    } catch (error) {
      console.error("Error al guardar sesión:", error);
      toast.error("❌ Error al guardar la sesión. Se intentará guardar localmente.");

      // En caso de error, guardar en cola offline (implementación simplificada)
      colaOfflineRef.current.push({
        tipo: 'sesion_completa',
        data: {
          sesion: dataRegistro,
          bloques: bloquesPendientesRef.current
        },
        timestamp: Date.now(),
      });
    }
  };

  // Main selection UI - No player code here
  // Navigation to /studia handled by empezarSesion() function


// Vista de listado (no hay sesión activa)
return (
  <div className="min-h-screen bg-background">
    {/* Header con estilo unificado */}
    <PageHeader
      icon={PlayCircle}
      title="Studia ahora"
      subtitle="Plan de estudio semanal"
      actions={
        (() => {
          const lunesSemana = parseLocalDate(semanaActualISO);
          const domingoSemana = new Date(lunesSemana);
          domingoSemana.setDate(lunesSemana.getDate() + 6);
          const numeroSemana = isoWeekNumberLocal(lunesSemana);
          const labelSemana = `Semana ${numeroSemana}`;
          const rangeTextSemana = `${lunesSemana.toLocaleDateString('es-ES', { day: 'numeric', month: 'short' })} – ${domingoSemana.toLocaleDateString('es-ES', { day: 'numeric', month: 'short', year: 'numeric' })}`;

          return (
            <PeriodHeader
              label={labelSemana}
              rangeText={rangeTextSemana}
              onPrev={() => cambiarSemana(-1)}
              onNext={() => cambiarSemana(1)}
              onToday={irSemanaActual}
            />
          );
        })()
      }
    />

    <div className="studia-section space-y-4">
      {/* Barra de contexto: pieza / plan / alumno en el body */}
      {asignacionActiva && (
        <div className="flex items-center gap-2 flex-wrap text-sm">
          <Music className="w-4 h-4 text-[var(--color-primary)] shrink-0" />
          <span className="font-semibold text-[var(--color-text-primary)]">{asignacionActiva.piezaSnapshot?.nombre}</span>
          <span className="text-[var(--color-text-secondary)]">·</span>
          <Target className="w-4 h-4 text-[var(--color-info)] shrink-0" />
          <span className="text-[var(--color-text-primary)]">{asignacionActiva.plan?.nombre}</span>
          <span className="text-[var(--color-text-secondary)]">·</span>
          <User className="w-4 h-4 text-[var(--color-text-secondary)] shrink-0" />
          <span className="font-medium text-[var(--color-text-primary)]">{getNombreVisible(alumnoActual)}</span>
        </div>
      )}

      {!asignacionActiva || !semanaDelPlan ? (
        <Card className="border-dashed border-2">
          <CardContent className="text-center py-16">
            <Target className={`w-20 h-20 mx-auto mb-4 ${componentStyles.empty.emptyIcon}`} />
            <h2 className={`${componentStyles.typography.pageTitle} mb-2`}>
              No tienes estudio esta semana
            </h2>
            <p className={`${componentStyles.empty.emptyText} mb-4`}>
              Consulta con tu profesor para obtener asignaciones
            </p>
            <Button
              variant="outline"
              onClick={() => {
                navigate(createPageUrl('estadisticas'), {
                  state: { from: 'hoy' }
                });
              }}
              className={`${componentStyles.buttons.outline} focus-brand`}
            >
              Ver mi historial y estadísticas →
            </Button>
          </CardContent>
        </Card>
      ) : (
        <>
          {/* Si hay múltiples asignaciones, mostrarlas como tarjetas en columna */}
          {asignacionesActivas.length > 1 ? (
            <div className="space-y-4">
              {asignacionesActivas.map((asignacion) => {
                const offsetAsignacion = calcularOffsetSemanas(asignacion.semanaInicioISO, semanaActualISO);
                const semanaAsignacion = asignacion.plan?.semanas?.[offsetAsignacion] || null;
                const isSelected = asignacionSeleccionadaId === asignacion.id || (!asignacionSeleccionadaId && asignacion.id === asignacionesActivas[0]?.id);

                if (!semanaAsignacion) return null;

                return (
                  <Card key={asignacion.id} className={`border-l-4 ${isSelected ? 'border-[var(--color-primary)]' : 'border-[var(--color-border-default)]'}`}>
                    <CardContent className="p-4">
                      {/* Header de asignación */}
                      <div className="mb-3">
                        <div className="flex items-center gap-2 mb-1 flex-wrap">
                          <Music className="w-4 h-4 text-[var(--color-primary)]" />
                          <span className="font-semibold text-[var(--color-text-primary)]">{asignacion.piezaSnapshot?.nombre}</span>
                          <span className="text-[var(--color-text-secondary)]">·</span>
                          <Target className="w-4 h-4 text-[var(--color-info)]" />
                          <span className="text-[var(--color-text-primary)]">{asignacion.plan?.nombre}</span>
                        </div>
                        <h2 className={`text-base font-bold text-[var(--color-text-primary)] font-headings`}>{semanaAsignacion.nombre}</h2>
                        <div className="flex items-center gap-2 mt-1 flex-wrap">
                          <Badge className={focoColors[semanaAsignacion.foco]}>
                            {focoLabels[semanaAsignacion.foco]}
                          </Badge>
                          <span className="text-sm text-[var(--color-text-secondary)]">
                            ({semanaAsignacion.sesiones?.length || 0} sesiones)
                          </span>
                        </div>
                        {semanaAsignacion.objetivo && (
                          <p className="text-sm text-[var(--color-text-secondary)] italic mt-1">"{semanaAsignacion.objetivo}"</p>
                        )}
                      </div>

                      {/* Sesiones - siempre visibles */}
                      {semanaAsignacion.sesiones && (
                        <div className="space-y-2">
                          {semanaAsignacion.sesiones.map((sesion, sesionIdx) => {
                            const tiempoTotal = calcularTiempoSesion(sesion);
                            const minutos = Math.floor(tiempoTotal / 60);
                            const segundos = tiempoTotal % 60;
                            const resumenExpandido = sesionesConResumenExpandido.has(`${asignacion.id}-${sesionIdx}`);

                            const toggleResumen = (e) => {
                              e.stopPropagation();
                              setSesionesConResumenExpandido(prev => {
                                const next = new Set(prev);
                                const key = `${asignacion.id}-${sesionIdx}`;
                                if (next.has(key)) {
                                  next.delete(key);
                                } else {
                                  next.add(key);
                                }
                                return next;
                              });
                            };

                            return (
                              <div
                                key={sesionIdx}
                                className={`border rounded-lg p-3 cursor-pointer hover:shadow-sm transition-all ${sesionSeleccionada === sesionIdx && isSelected
                                  ? `border-[var(--color-primary)] bg-[var(--color-primary-soft)] shadow-sm`
                                  : `border-[var(--color-border-default)] bg-[var(--color-surface-default)] hover:bg-[var(--color-surface-muted)]`
                                  }`}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setAsignacionSeleccionadaId(asignacion.id);
                                  setSesionSeleccionada(sesionIdx);
                                }}
                              >
                                <div className="space-y-3">
                                  {/* Header de la sesión: chip + tiempo + foco */}
                                  <div className="flex items-center gap-2 flex-wrap">
                                    <Badge variant="outline" className="text-xs px-2 py-0.5 bg-[var(--color-surface-muted)]">
                                      {sesion.nombre}
                                    </Badge>
                                    <Badge
                                      variant="outline"
                                      className={`text-xs px-2 py-0.5 ${componentStyles.status.badgeSuccess}`}
                                    >
                                      <Clock className="w-3 h-3 mr-1" />
                                      {minutos}:{String(segundos).padStart(2, '0')} min
                                    </Badge>
                                    <Badge className={`${focoColors[sesion.foco]} text-xs px-2 py-0.5`} variant="outline">
                                      Foco: {focoLabels[sesion.foco]}
                                    </Badge>
                                    {sesion.foco !== semanaAsignacion.foco && (
                                      <Badge className="bg-purple-100 text-purple-700 text-xs px-2 py-0.5" variant="outline">
                                        <Shuffle className="w-3 h-3 mr-1" />
                                        Repaso
                                      </Badge>
                                    )}
                                  </div>

                                  {/* Botón para desplegar/colapsar ejercicios */}
                                  <button
                                    className={`w-full flex items-center gap-2 p-1.5 rounded-lg transition-colors ${resumenExpandido ? 'bg-[var(--color-surface-muted)]' : 'hover:bg-[var(--color-surface-muted)]'
                                      }`}
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      toggleResumen(e);
                                    }}
                                  >
                                    {resumenExpandido ? (
                                      <ChevronDown className="w-4 h-4 text-[var(--color-text-secondary)]" />
                                    ) : (
                                      <ChevronRight className="w-4 h-4 text-[var(--color-text-secondary)]" />
                                    )}
                                    <span className="text-sm font-medium text-[var(--color-text-primary)]">
                                      {resumenExpandido ? 'Ocultar ejercicios' : 'Ver ejercicios'}
                                    </span>
                                  </button>

                                  {/* Resumen expandido */}
                                  {resumenExpandido && (
                                    <div className="border-t border-[var(--color-border-default)] pt-2" onClick={(e) => e.stopPropagation()}>
                                      <SessionContentView sesion={sesion} compact dbBloques={bloquesActuales} semanaFoco={semanaAsignacion.foco} />
                                    </div>
                                  )}

                                  {/* Botón de iniciar práctica (solo si está seleccionada) */}
                                  {sesionSeleccionada === sesionIdx && isSelected && (
                                    <div className="pt-2 border-t border-[var(--color-border-default)] flex justify-center" onClick={(e) => e.stopPropagation()}>
                                      <Button
                                        variant="primary"
                                        onClick={(e) => {
                                          e.stopPropagation();
                                          empezarSesion(sesion, sesionIdx);
                                        }}
                                        size="lg"
                                        className={`${componentStyles.buttons.primary} w-full md:w-auto h-12 shadow-sm`}
                                      >
                                        <PlayCircle className="w-5 h-5 mr-2" />
                                        Studia ahora
                                      </Button>
                                    </div>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </CardContent>
                  </Card>
                );
              })}
            </div>
          ) : (
            /* Una sola asignación: mostrar como antes pero sin toggle de sesiones */
            <div className="border-l-4 border-[var(--color-primary)] bg-[var(--color-primary-soft)]/50 rounded-r-lg p-3">
              {/* Información de la semana - siempre visible */}
              <div className="mb-3">
                <div className="flex items-center gap-2 mb-1 flex-wrap">
                  <h2 className={`text-base font-bold text-[var(--color-text-primary)] font-headings`}>{semanaDelPlan.nombre}</h2>
                  <Badge className={focoColors[semanaDelPlan.foco]}>
                    {focoLabels[semanaDelPlan.foco]}
                  </Badge>
                  <span className="text-sm text-[var(--color-text-secondary)]">
                    ({semanaDelPlan.sesiones?.length || 0} sesiones)
                  </span>
                </div>
                {semanaDelPlan.objetivo && (
                  <p className="text-sm text-[var(--color-text-secondary)] italic mt-1">"{semanaDelPlan.objetivo}"</p>
                )}
              </div>

              {/* Sesiones - siempre visibles */}
              {
                semanaDelPlan.sesiones && (
                  <div className="space-y-2">
                    {semanaDelPlan.sesiones.map((sesion, sesionIdx) => {
                      const tiempoTotal = calcularTiempoSesion(sesion);
                      const minutos = Math.floor(tiempoTotal / 60);
                      const segundos = tiempoTotal % 60;
                      const resumenExpandido = sesionesConResumenExpandido.has(sesionIdx);

                      const toggleResumen = (e) => {
                        e.stopPropagation();
                        setSesionesConResumenExpandido(prev => {
                          const next = new Set(prev);
                          if (next.has(sesionIdx)) {
                            next.delete(sesionIdx);
                          } else {
                            next.add(sesionIdx);
                          }
                          return next;
                        });
                      };

                      return (
                        <div
                          key={sesionIdx}
                          className={`border rounded-lg p-3 cursor-pointer hover:shadow-sm transition-all ${sesionSeleccionada === sesionIdx
                            ? `border-[var(--color-primary)] bg-[var(--color-primary-soft)] shadow-sm`
                            : `border-[var(--color-border-default)] bg-[var(--color-surface-default)] hover:bg-[var(--color-surface-muted)]`
                            }`}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSesionSeleccionada(sesionIdx);
                          }}
                        >
                          <div className="space-y-3">
                            {/* Header de la sesión: chip + tiempo + foco */}
                            <div className="flex items-center gap-2 flex-wrap">
                              <Badge variant="outline" className="text-xs px-2 py-0.5 bg-[var(--color-surface-muted)]">
                                {sesion.nombre}
                              </Badge>
                              <Badge
                                variant="outline"
                                className={`text-xs px-2 py-0.5 ${componentStyles.status.badgeSuccess}`}
                              >
                                <Clock className="w-3 h-3 mr-1" />
                                {minutos}:{String(segundos).padStart(2, '0')} min
                              </Badge>
                              <Badge className={`${focoColors[sesion.foco]} text-xs px-2 py-0.5`} variant="outline">
                                Foco: {focoLabels[sesion.foco]}
                              </Badge>
                            </div>

                            {/* Botón para desplegar/colapsar ejercicios */}
                            <button
                              className={`w-full flex items-center gap-2 p-1.5 rounded-lg transition-colors ${resumenExpandido ? 'bg-[var(--color-surface-muted)]' : 'hover:bg-[var(--color-surface-muted)]'
                                }`}
                              onClick={(e) => {
                                e.stopPropagation();
                                toggleResumen(e);
                              }}
                            >
                              {resumenExpandido ? (
                                <ChevronDown className="w-4 h-4 text-[var(--color-text-secondary)]" />
                              ) : (
                                <ChevronRight className="w-4 h-4 text-[var(--color-text-secondary)]" />
                              )}
                              <span className="text-sm font-medium text-[var(--color-text-primary)]">
                                {resumenExpandido ? 'Ocultar ejercicios' : 'Ver ejercicios'}
                              </span>
                            </button>

                            {/* Resumen expandido */}
                            {resumenExpandido && (
                              <div className="border-t border-[var(--color-border-default)] pt-2" onClick={(e) => e.stopPropagation()}>
                                <SessionContentView sesion={sesion} compact dbBloques={bloquesActuales} semanaFoco={semanaDelPlan?.foco} />
                              </div>
                            )}

                            {/* Botón de iniciar práctica (solo si está seleccionada) */}
                            {sesionSeleccionada === sesionIdx && (
                              <div className="pt-2 border-t border-[var(--color-border-default)] flex justify-center" onClick={(e) => e.stopPropagation()}>
                                <Button
                                  variant="primary"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    empezarSesion(sesion, sesionIdx);
                                  }}
                                  size="lg"
                                  className={`${componentStyles.buttons.primary} w-full md:w-auto h-12 shadow-sm`}
                                >
                                  <PlayCircle className="w-5 h-5 mr-2" />
                                  Iniciar Práctica
                                </Button>
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )
              }
            </div>
          )}

          <div className="flex flex-wrap items-center justify-center gap-3 pt-4 border-t">
            <Button
              variant="outline"
              onClick={() => {
                const params = new URLSearchParams();
                params.set('tab', 'mochila');
                if (effectiveUserId) {
                  params.set('students', effectiveUserId);
                }
                navigate(`/progreso?${params.toString()}`);
              }}
              className="rounded-xl focus-brand"
            >
              <Backpack className="w-4 h-4 mr-2" />
              Ver Mochila
            </Button>
            <Button
              variant="outline"
              onClick={() => {
                navigate(createPageUrl('estadisticas'), {
                  state: { from: 'hoy' }
                });
              }}
              className="rounded-xl focus-brand"
            >
              Ver Historial y estadísticas →
            </Button>
          </div>
        </>
      )}
    </div>
  </div>
);
}

